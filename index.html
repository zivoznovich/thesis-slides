<!doctype html>
<html lang="en">
	<head>
		 <meta charset="utf-8" />
		 <title>On Deterministically Finding an Element of High Order Modulo a Composite</title>
		 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		 <link rel="stylesheet" href="dist/reveal.css" />
		 <link rel="stylesheet" href="dist/theme/white.css" id="theme" />
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>
						On Deterministically Finding an Element
						<br>
						of High Order Modulo a Composite
					</h1>
					<p><strong>Ziv Oznovich</strong> and <strong>Ben Lee Volk</strong></p>
					<p>Reichman University</p>
				</section>
				<section>
					<h1>
						Integer Factorization
					</h1>
					<ul>
						<li class="fragment">
							Given a positive integer \( N \), find integers $p_i, q_j$ such that
							<ul>
								<li class="fragment">\( N = p_1^{q_1} \cdot p_2^{q_2} \cdot \dots \cdot p_k^{q_k} \)</li>
								<li class="fragment">$p_i$'s are prime</li>
							</ul>
						</li>
						<li class="fragment">Note that the input size is \( O(\log N) \)</li>
					</ul>
				</section>
				<section>
					<h1>Motivation</h1>
					<ul>
						<li class="fragment">Integer factorization is a fundamental problem in computational number theory</li>
						<li class="fragment">RSA encryption relies on the hardness of factoring $N = pq$</li>
						<li class="fragment">
							Derandomization is believed to be possible with only polynomial slowdown
							<br><br>
							<table class="fragment">
								<tr>
									<th>Randomized algorithms</th>
									<th >Deterministic algorithms</th>
								</tr>
								<tr>
									<td>$\exp(\tilde{O}(\sqrt{\log N}))$</td>
									<td>$N^{1/4+o(1)}$ (70's, Strassen and Pollard)</td>
								</tr>
								<tr>
									<td class="fragment">üôÇ</td>
									<td>$N^{1/5+o(1)}$ (2021-22, Hittmeir and Harvey)</td>
								</tr>
							</table>
							<li class="fragment"><em>"Deterministic algorithms" = Deterministic, rigorously proven algorithms</em></li>
						</li>
					</ul>
				</section>
				<section>
					<h1>The Role of Multiplicative Order in Factorization</h1>
					<ul>
						<li class="fragment"><strong>Finding large-order elements</strong> is a natural derandomization problem
							<ul>
								<li class="fragment">Most elements in $\mathbb{Z}_N^*$ have large order, but it is unclear how to <b>find one deterministically</b></li>
							</ul>
						</li>
						<li class="fragment">Latest factorization algorithm relies on finding $a \in \mathbb{Z}_N^*$ with a <b>large multiplicative order</b>
							<ul>
								<li class="fragment">They specifically require finding an element whose order is at least roughly $N^{1/5}$</li>
								<li class="fragment">Such an element doesn't necessarily exist</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h1>Definitions</h1>
					<ul>
						<li class="fragment">
							$\mathbb{Z}_N^*$ ‚Äì Multiplicative Group of Integers Modulo $N$
							<ul>
								<li class="fragment">Consists of all integers $a$ such that $1 \le a &lt; N$ and $\gcd(a, N) = 1$</li>
								<li class="fragment"><i>Example (for $N = 15$):</i> $\mathbb{Z}_{15}^* = \{1, 2, 4, 7, 8, 11, 13, 14\}$</li>
							</ul>
						</li>

						<li class="fragment">
							$\mathrm{ord}_N(a)$ ‚Äì Order of an Element $a$ Modulo $N$
							<ul>
								<li class="fragment">The smallest positive integer $k$ such that $a^k \equiv 1 \pmod{N}$</li>
								<li class="fragment"><i>Example (for $a = 2$, $N = 15$):</i> $2^1 = 2$, $2^2 = 4$, $2^3 = 8$, $2^4 = 16 \equiv 1 \pmod{15}$</li>
								<li class="fragment">So $\mathrm{ord}_{15}(2) = 4$</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h1>Hittmeir's Algorithm (2018)</h1>
					<ul>
						<li class="fragment">Given composite \(N\) and \(D \ge N^{2/5}\)</li>
						<li class="fragment">Runs in time \(D^{1/2+o(1)}\)</li>
						<li class="fragment">
							Outputs
							<ul>
								<li>an element $a \in \mathbb{Z}_N^*$ of multiplicative order at least \(D\)</li>
								<li class="fragment">or a non‚Äëtrivial factor of \(N\)</li>
								<li class="fragment">As a subroutine in a factorization algorithm this is a ‚Äúwin‚Äëwin‚Äù result</li>
							</ul>
						</li>
						<li class="fragment">Large-order elements may not always exist</li>
						<li class="fragment">When applied with \(D=N^{2/5}\), it runs in \(N^{1/5+o(1)}\) time, matching other algorithm steps</li>
					</ul>
				</section>
				<section>
					<h1>Our Result</h1>
					<ul>
						<li class="fragment">We give a deterministic algorithm based on Hittmeir&#39;s algorithm</li>
						<li class="fragment">Runs in time $D^{1/2+o(1)}$
							<ul>
								<li>Same as previous result</li>
							</ul>
						</li>
						<li class="fragment">It works for a <strong>wider range of parameters</strong> namely $D \ge N^{1/6}$
							<ul>
								<li>Compared to $D \ge N^{2/5}$</li>
							</ul>
						</li>
						<li class="fragment">This enables finding an element of order $N^{1/5}$ in $N^{1/10+o(1)}$ time for the factorization algorithm
							<ul>
								<li>Compared to finding an element of order $N^{2/5}$ in $N^{1/5+o(1)}$ time</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h1>Main Algorithm Simplified Overview</h1>
					<ul>
						<li class="fragment">
							Try \(a = 2, 3, \dots\)
							<ul>
								<li class="fragment">
									<b>If</b> \(\mathrm{ord}_N(a) > D\) <b>return</b> \(a\)
								</li>
								<li class="fragment">
									\(M \gets \mathrm{lcm}(M, \mathrm{ord}_N(a))\)
								</li>
								<li class="fragment">
									<b>If</b> \(M \ge D\)
									<ul>
										<li class="fragment">
											Deduce that all prime divisors of \(N\) are \(1 \pmod M\)<br>
											and use this to factor \(N\)
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>

				</section>
				<section>
					<h1>Shanks' Method for Order Computation</h1>
					<ul>
						<li class="fragment" data-fragment-index="1"><b>Goal:</b> If $\operatorname{ord}_N(a) < D$ calculate it, otherwise, state that it is larger than $D$</li>
						<li class="fragment" data-fragment-index="2">
							<strong>Shanks' Baby-Step Giant-Step</strong> algorithm:
							<ul>
								<li class="fragment" id="shanks-switch" data-fragment-index="3">$a^k\equiv 1 \pmod N, k \leq D$</li>
								<li class="fragment" data-fragment-index="4">
									Write $k=i\sqrt D + j, 0< i,j \leq \sqrt D$
									<span class="fragment" data-fragment-index="5" switch-text="true" target-id="shanks-switch" target-text-forward="$a^{i\sqrt D + j}\equiv 1 \pmod N$" target-text-backward="$a^k\equiv 1 \pmod N, k \leq D$"></span>
									<span class="fragment" data-fragment-index="6" switch-text="true" target-id="shanks-switch" target-text-forward="$a^{i\sqrt D}\equiv a^{-j} \pmod N$" target-text-backward="$a^{i\sqrt D + j}\equiv 1 \pmod N$"></span>
								</li>
							</ul>
						</li>
						<div style="display: flex; justify-content: center; max-width: 50%; align-content: center; align-items: center; margin: 0 auto 1.2vw auto;">
							<table class="fragment" data-fragment-index="7" style="font-size: 1.3vw">
								<tr>
									<td>$a^{\sqrt D}$</td>
								</tr>
								<tr>
									<td>$a^{2 \sqrt D}$</td>
								</tr>
								<tr>
									<td>...</td>
								</tr>
								<tr>
									<td>$a^{D}$</td>
								</tr>
							</table>
							<div class="fragment" data-fragment-index="9">Find a match</div>
							<table class="fragment" data-fragment-index="8">
								<tr>
									<td>$a^{-1}$</td>
								</tr>
								<tr>
									<td>$a^{-2}$</td>
								</tr>
								<tr>
									<td>...</td>
								</tr>
								<tr>
									<td>$a^{-\sqrt D}$</td>
								</tr>
							</table>
						</div>
						<li class="fragment" data-fragment-index="10"><strong>Time Complexity</strong>: $\tilde{O}(\sqrt{D})$</li>
					</ul>
				</section>
				<section>
					<h1>Factoring Given the Residue Class of Divisors</h1>
					<ul>
						<li class="fragment">
							Both Lenstra (84), and Coppersmith, Howgrave-Graham and Nagaraj (08)
							<ul>
								<li>
									Give $s\geq N^\alpha, \alpha > 1/4$
								</li>
								<li class="fragment">
									Find all divisors of $N$ that are congruent to $t \pmod s$ in <b>polynomial-time!</b>
								</li>
							</ul>
						</li>
						<li class="fragment">
							In our case we deduce $p\equiv 1 \pmod D$
							<ul>
								<li class="fragment">
									So $D \geq N^{1/4}$ gives a polynomial-time factorization step
								</li>
								<li class="fragment">
									But we can allow $\sqrt D = N^{ \alpha / 2 } $ run time
								</li>
								<li>
									Adjusting [CHGN08] we achieve $N^{1/4-\alpha}$ time
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h1>Factoring Given the Residue Class of Divisors</h1>
					<ul>
						<li class="fragment">
							Based on Harvey‚ÄìHittmeir‚Äôs algorithm (2022) for finding all $r$&#39;th power divisors
							<ul>
								<li class="fragment">Utilizing the $p \equiv 1 \pmod s$ information to reduce the runtime by a factor of $s$</li>
							</ul>
						</li>
						<li class="fragment">
							<b>Proof sketch:</b>
							<ul>
								<li class="fragment">
									Construct set of polynomials $f_i(x)$ that vanish on the divisors $\pmod N$
								</li>
								<li class="fragment">
									Find polynomial $h(x) with small coefficients in the lattice spanned by $f_i(x)$'s (using LLL)
								</li>
								<li class="fragment">
									Find roots of $h(x)$ over the integers
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h1>Conclusion</h1>
					<ul>
						<li class="fragment">
							Our Work
							<ul>
								<li class="fragment">We provide a deterministic algorithm for finding elements of large multiplicative order, with improved parameter range</li>
								<li class="fragment">This contributes to improving the efficiency of part of the current fastest deterministic integer factorization algorithm</li>
							</ul>
						</li>
						<li class="fragment">
							Open Problems
							<ul>
								<li class="fragment">Deterministic factorization in $N^{1/6}$?</li>
								<li class="fragment">Deterministically finding a generator in the cyclic group $\mathbb{Z}_p^*$?</li>
							</ul>
						</li>
						<li class="fragment">
							Thanks <strong>Ben Lee Volk</strong>
						</li>
						<li class="fragment">
							Questions?
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/math/math.js"></script>

		<script>
			Reveal.initialize({
				hash: true,
				plugins: [ RevealMath.KaTeX ],
				markdown: {
					smartypants: true
				},
				mathjax3: {
					tex: {
						inlineMath: [['$', '$'], ['\\(', '\\)']],
						displayMath: [['$$', '$$'], ['\\[', '\\]']]
					}
				},
				width: "100%",
				height: "100%",
				margin: 0.2,
				minScale: 0.2,
				maxScale: 1.5,
				controls: true,
				responsive: true,
			});

			function math(targetElement) {
				renderMathInElement(targetElement, {
					delimiters: [
						{left: "$$", right: "$$", display: true},
						{left: "$", right: "$", display: false},
						{left: "\\[", right: "\\]", display: true},
						{left: "\\(", right: "\\)", display: false}
					]
				});
			}

			function switchText(event, isForward) {
				if (event.fragment.getAttribute('switch-text') === 'true') {
					event.fragment.style.display = 'none';

					const targetId = event.fragment.getAttribute('target-id');
					const targetText = isForward ? event.fragment.getAttribute('target-text-forward') : event.fragment.getAttribute('target-text-backward');
					const targetElement = document.getElementById(targetId);

					targetElement.style.transition = 'opacity 0.5s ease-out';
					targetElement.style.opacity = '0';

					setTimeout(() => {
						targetElement.textContent = targetText;
						math(targetElement);
						targetElement.style.opacity = '1';
					}, 500);
				}
			}

			Reveal.on('fragmenthidden', (event) => {
				switchText(event, false);
			});

			Reveal.on('fragmentshown', (event) => {
				switchText(event, true);
			})
		</script>
	</body>
</html>