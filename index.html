<!doctype html>
<html lang="en">
	<head>
		 <meta charset="utf-8" />
		 <title>On Deterministically Finding an Element of High Order Modulo a Composite</title>
		 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css" />
		 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/white.css" id="theme" />
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1 id="on-deterministically-finding-an-element-of-high-order-modulo-a-composite">On Deterministically Finding an Element of High Order Modulo a Composite</h1>
					<p><strong>Ziv Oznovich</strong> and <strong>Ben Lee Volk</strong></p>
					<p>Reichman University</p>
				</section>
				<section>
					<h2 id="motivation">Motivation</h2>
					<ul>
						<li><strong>Derandomization</strong> is believed to be possible with <em>only</em> polynomial slowdown</li>
						<li><span class="fragment"><strong>Computational Number Theory</strong> features problems where randomized algorithms significantly outperform deterministic ones</span></li>
					</ul>
				</section>
				<section>
					<h2 id="integer-factorization-derandomization">Integer Factorization Derandomization</h2>
					<ul>
						<li>Fundamental to the security of <strong>RSA encryption</strong>, which relies on the hardness of factoring $N = pq$ for large primes $p, q$
							<span class="fragment"></li>
						<li>Best known randomized algorithm runs in time $\exp(\tilde{O}(\sqrt{\log N}))$
							</span>
							<span class="fragment"></li>
						<li>Best known deterministic algorithms from the 70&#39;s were $N^{1/4+o(1)}$
							</span><blockquote>
								<p>By Strassen and Pollard</p>
							</blockquote>
						</li>
						<li>Recent (2021-22) deterministic breakthroughs achieved $N^{1/5+o(1)}$<blockquote>
							<p>By Hittmeir and Harvey</p>
						</blockquote>
						</li>
					</ul>
				</section>
				<section>
					<h2 id="the-role-of-multiplicative-order-in-factorization">The Role of Multiplicative Order in Factorization</h2>
					<ul>
						<li><strong>Finding large-order elements</strong> is a natural derandomization problem<blockquote>
							<p>Most elements in $\mathbb{Z}_N^<em>$ have large order, but it is unclear how to <em>*find one deterministically</em></em></p>
						</blockquote>
						</li>
						<li>The latest deterministic factorization algorithm relies on finding an element $a \in \mathbb{Z}_N^<em>$ with a <em>*large multiplicative order</em></em><blockquote>
							<p>They specifically require finding an element whose order is at least roughly $N^{1/5}$</p>
						</blockquote>
						</li>
					</ul>
				</section>
				<section>
					<h2 id="definitions">Definitions</h2>
					<h3 id="-mathbb-z-_n-multiplicative-group-of-integers-modulo-n-">$\mathbb{Z}_N^*$ - Multiplicative Group of Integers Modulo $N$</h3>
					<ul>
						<li>Consists of all integers $a$ such that $1 \le a &lt; N$ and $\gcd(a, N) = 1$</li>
					</ul>
					<h3 id="-text-ord-_n-a-order-of-an-element-a-modulo-n-">$\text{ord}_N(a)$ -  Order of an Element $a$ Modulo $N$</h3>
					<ul>
						<li>The smallest positive integer $k$ such that $a^k \equiv 1 \pmod{N}$</li>
					</ul>
				</section>
				<section>
					<h2 id="previous-results-hittmeir-s-algorithm-2018-">Previous Results - Hittmeir&#39;s Algorithm (2018)</h2>
					<ul>
						<li>Given composite $N$ and $D \ge N^{2/5}$</li>
						<li>Runs in time $D^{1/2+o(1)}$</li>
						<li>Outputs<ul>
							<li>an element $a \in \mathbb{Z}_N^*$ of multiplicative order at least $D$</li>
							<li>or a nontrivial factor of $N$<blockquote>
								<p>As a subroutine in a factorization algorithm this is a &quot;win-win&quot; result</p>
							</blockquote>
							</li>
						</ul>
						</li>
						<li>When applied with $D=N^{2/5}$, it runs in $N^{1/5+o(1)}$ time, matching other algorithm steps</li>
					</ul>
				</section>
				<section>
					<h2 id="our-result">Our Result</h2>
					<ul>
						<li>We give a deterministic algorithm based on Hittmeir&#39;s algorithm</li>
						<li>Runs in time $D^{1/2+o(1)}$<blockquote>
							<p>Same as previous result</p>
						</blockquote>
						</li>
						<li>It works for a <strong>wider range of parameters</strong> namely $D \ge N^{1/6}$<blockquote>
							<p>Compared to $D \ge N^{2/5}$</p>
						</blockquote>
						</li>
						<li>This enables finding an element of order $N^{1/5}$ in $N^{1/10+o(1)}$ time for the factorization algorithm<blockquote>
							<p>Compared to finding an element of order $N^{2/5}$ in $N^{1/5+o(1)}$ time</p>
						</blockquote>
						</li>
					</ul>
				</section>
				<section>
					<h2 id="main-algorithm-simplified-overview">Main Algorithm Simplified Overview</h2>
					<ul>
						<li>Try $a = 2, 3, \dots$<ul>
							<li><strong>While</strong> $a^M\equiv 1 \pmod N$: $a\gets a+1$</li>
							<li>Let $m = \mathrm{ord}_N(a)$</li>
							<li><strong>If</strong> $m &gt; D$: <strong>return</strong> $a$</li>
							<li><strong>Else</strong>:<ul>
								<li>$M \gets \mathrm{lcm}(M, m)$</li>
							</ul>
							</li>
						</ul>
						</li>
						<li>When $M \ge D$<ul>
							<li>Learn $p\equiv 1 \pmod M$ for divisors of $N$</li>
							<li>Use this to factor $N$</li>
						</ul>
						</li>
					</ul>
				</section>
				<section>
					<h2 id="shanks-method-for-order-computation">Shanks&#39; Method for Order Computation</h2>
					<ul>
						<li><strong>Goal</strong>: Given $a \in \mathbb{Z}_N^*$<ul>
							<li>if $\operatorname{ord}_N(a) &lt; D$ calculate it</li>
							<li>else, state $\operatorname{ord}_N(a) &gt; D$</li>
						</ul>
						</li>
						<li><strong>Shanks&#39; Baby-Step Giant-Step</strong> algorithm:<ul>
							<li>Precompute $a^j$ for $0 \le j &lt; \lceil \sqrt{D} \rceil$ (baby steps)</li>
							<li>Compute $a^{-i\lceil \sqrt{D} \rceil}$ for $0 \le i &lt; \lceil \sqrt{D} \rceil$ (giant steps)</li>
							<li>Search for collision: $a^{i\lceil \sqrt{D} \rceil + j} \equiv 1 \mod N$</li>
						</ul>
						</li>
						<li><strong>Time Complexity</strong>: $\tilde{O}(\sqrt{D})$</li>
					</ul>
				</section>
				<section>
					<h2 id="consecutive-roots-bound-improvement">Consecutive Roots Bound Improvement</h2>
					<ul>
						<li>Hittmeir upper bounds the number of consecutive elements $a$ satisfying $a^M\equiv 1 \pmod N$ by $M$</li>
						<li>Forbes, Kayal, Mittal and Saha (2011) give a bound on the number of common roots of a set of polynomials $S={(x+a_i)^\ell-\theta<em>i}</em>{1\leq i\leq k}$</li>
						<li>We use their lemma to bound $a^M\equiv 1 \pmod N$ by $O(\sqrt{M})$ consecutive roots</li>
					</ul>
				</section>
				<section>
					<h2 id="factoring-given-the-residue-class-of-divisors">Factoring Given the Residue Class of Divisors</h2>
					<ul>
						<li>Based on Harvey‚ÄìHittmeir‚Äôs algorithm (2022) for finding all $r$&#39;th power divisors</li>
						<li>Utilizing the $p \equiv 1 \pmod s$ information to reduce the runtime by a factor of $s$</li>
						<li>Define polynomials $f_i(x)$ that vanishe on a small root related to the divisor</li>
						<li>Build lattice from $f_i(x)$</li>
						<li>Apply &quot;Lenstra‚ÄìLenstra‚ÄìLov√°sz&quot; lattice base reduction</li>
						<li>Get small-norm polynomial $h(x)$</li>
						<li>Find small roots over the integers</li>
					</ul>
				</section>
				<section>
					<h2 id="conclusion">Conclusion</h2>
					<ul>
						<li>We provide a deterministic algorithm for finding elements of large multiplicative order, with improved parameter range</li>
						<li>This contributes to improving the efficiency of part of the current fastest deterministic integer factorization algorithm</li>
					</ul>
				</section>
				<section>
					<h1 id="thanks-ben-lee-volk-">Thanks <strong>Ben Lee Volk</strong> üôè</h1>
					<h1 id="questions-">Questions?</h1>
				</section>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/markdown/markdown.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/notes/notes.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/math/math.js"></script>

		<script>
			Reveal.initialize({
				hash: true,
				plugins: [ RevealMarkdown, RevealNotes, RevealHighlight, RevealMath.KaTeX ],
				markdown: {
					smartypants: true
				},
				mathjax3: {
					tex: {
						inlineMath: [['$', '$'], ['\\(', '\\)']],
						displayMath: [['$$', '$$'], ['\\[', '\\]']]
					}
				},
				width: "100%",
				height: "100%",
				margin: 0.1,
				minScale: 0.2,
				maxScale: 1.5
			});
		</script>
	</body>
</html>